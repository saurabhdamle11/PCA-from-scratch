# -*- coding: utf-8 -*-
"""ass3_aml.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1jgz9WWg1m0D4Ke2iSo4_su210aNAuaxB

# CSCI P 556 Applied Machine Learning

### Homework 3

### Team Members
Saurabh Damle
Soham Bhagwat 
Bhadrayu Godbole

### Question 1
"""

# Importing the required libraries
import numpy as np
import pandas as pd
from PIL import Image
import matplotlib.pyplot as plt
import argparse

"""Function definitions"""

def get_image(image_name): 
    '''
    Function to import image for carrying out PCA
    '''
    image = Image.open(str(image_name)) 
    image_array = np.array(image)
    return image_array

def separate(image_arr):
    '''
    Function for separating image into 3 components
    '''
    red_component = image_arr[:,:,0]
    green_component = image_arr[:,:,1]
    blue_component = image_arr[:,:,2]
    return red_component, green_component, blue_component

def centered_mean(comp):
  '''
  Function to calculate centered mean for a given component
  '''
  calculation = comp - np.mean(comp, axis = 0)
  return calculation

def covariance_calculator(m_comp):
  '''
  Function to calculate covariance for a given component whose centered mean is calculated
  '''
  return np.cov(m_comp)

def actual_transformer(eig_subset, m_comp):
  '''
  Function to reduce the number of dimensions for a given component
  '''
  return np.dot(eig_subset.transpose(), m_comp)

def reconstruct(eig_subset, reduced_comp, component):
  '''
  Function to reconstruct the component after reducing dimensions
  '''
  reconstructed_component_calc = np.dot(eig_subset, reduced_comp) + np.mean(component, axis = 0).T
  return reconstructed_component_calc

def PCA_transformer(component, dimensions):
  '''
  Function for carrying out all the calculations for doing the actual PCA
  '''
  meaned_component = centered_mean(component) # First we calculate centered mean of the component
  # print("cov = meaned", meaned_component.shape)
  covariance_matrix = covariance_calculator(meaned_component) # Then we calculate covariance matrix to help us find eigen values and eigenvectors
  eigen_values, eigen_vectors = np.linalg.eigh(covariance_matrix) # Eigen values and eigen vectors are found
  sorted_index = np.argsort(eigen_values)[::-1] # Configuring index for sorting the above values in descending order
  sorted_eigenvalue = eigen_values[sorted_index]  # Sorting the eigenvalues in descending order
  sorted_eigenvectors = eigen_vectors[:,sorted_index] # Sorting the eigen vectors in descending order
  eigenvector_subset = sorted_eigenvectors[:,:dimensions] # Finding a subset by selecting only the desired PCs
  # print("eig vec = subset", eigenvector_subset.shape)

  reduced_component = actual_transformer(eigenvector_subset, meaned_component)  # Actual dimension compression 
  # print("score = X_reduced", reduced_component.shape)
  var_component = reduced_component.var(axis=1) # Calculating variance along each row

  reconstructed_component = reconstruct(eigenvector_subset, reduced_component, component) # Reconstructing the image with reduced dimensions
  reconstructed_component = np.uint8(np.absolute(reconstructed_component))  # Making the image data into a uint8 format
  # print("recon", reconstructed_component.shape)

  vals_component = []
  for i in var_component:
    each_var = i/sum(var_component)
    vals_component.append(each_var) # This list contains the ratio of explained variance/total variance

  return reconstructed_component, vals_component

if __name__ == '__main__':
    '''
    Main function for argparse and further PCA
    '''
    parser = argparse.ArgumentParser()
    parser.add_argument('-img', type=str, help="Image name/path(string)")
    args = parser.parse_args()
    image_array = get_image(args.img)
    r, g, b = separate(image_array)
    
    """Output for 50 Principal Components"""
    
    red_recon, vals_red = PCA_transformer(r, 100)  # Gathering all the reconstructed image data for red component
    green_recon, vals_green = PCA_transformer(g, 100)  # Gathering all the reconstructed image data for green component
    blue_recon, vals_blue = PCA_transformer(b, 100) # Gathering all the reconstructed image data for blue component
    final_image = np.dstack((red_recon, green_recon, blue_recon))
    final_image = Image.fromarray(final_image)

    plt.suptitle("Output Image for 100 Principal Components")
    plt.imshow(final_image) # Final image after image compression using PCA

    # Plot for showing the Accumulative Variance v/s Number of PCs for red channel
    fig = plt.figure(figsize=(13, 10))
    fig.add_subplot(131)
    plt.title("Red Channel")
    plt.ylabel("Accumulative Variance")
    plt.xlabel("Number of PCs")
    plt.bar(list(range(1,101)), vals_red, color = "red")

    # Plot for showing the Accumulative Variance v/s Number of PCs for green channel
    fig.add_subplot(132)
    plt.title("Green Channel")
    plt.ylabel("Accumulative Variance")
    plt.xlabel("Number of PCs")
    plt.bar(list(range(1,101)), vals_green, color = "green")

    # Plot for showing the Accumulative Variance v/s Number of PCs for blue channel
    fig.add_subplot(133)
    plt.title("Blue Channel")
    plt.ylabel("Accumulative Variance")
    plt.xlabel("Number of PCs")
    plt.bar(list(range(1,101)), vals_blue, color = "blue")

    plt.suptitle("Output for 100 Principal Components")
    plt.show()

    """Output for 50 Principal Components"""

    red_recon, vals_red = PCA_transformer(r, 50)  # Gathering all the reconstructed image data for red component
    green_recon, vals_green = PCA_transformer(g, 50)  # Gathering all the reconstructed image data for green component
    blue_recon, vals_blue = PCA_transformer(b, 50) # Gathering all the reconstructed image data for blue component
    final_image = np.dstack((red_recon, green_recon, blue_recon))
    final_image = Image.fromarray(final_image)

    plt.suptitle("Output Image for 50 Principal Components")
    plt.imshow(final_image) # Final image after image compression using PCA

    # Plot for showing the Accumulative Variance v/s Number of PCs for red channel
    fig = plt.figure(figsize=(13, 10))
    fig.add_subplot(131)
    plt.title("Red Channel")
    plt.ylabel("Accumulative Variance")
    plt.xlabel("Number of PCs")
    plt.bar(list(range(1,51)), vals_red, color = "red")

    # Plot for showing the Accumulative Variance v/s Number of PCs for green channel
    fig.add_subplot(132)
    plt.title("Green Channel")
    plt.ylabel("Accumulative Variance")
    plt.xlabel("Number of PCs")
    plt.bar(list(range(1,51)), vals_green, color = "green")

    # Plot for showing the Accumulative Variance v/s Number of PCs for blue channel
    fig.add_subplot(133)
    plt.title("Blue Channel")
    plt.ylabel("Accumulative Variance")
    plt.xlabel("Number of PCs")
    plt.bar(list(range(1,51)), vals_blue, color = "blue")

    plt.suptitle("Output for 50 Principal Components")
    plt.show()

    """Output for 200 Principal Components"""

    red_recon, vals_red = PCA_transformer(r, 200)  # Gathering all the reconstructed image data for red component
    green_recon, vals_green = PCA_transformer(g, 200)  # Gathering all the reconstructed image data for green component
    blue_recon, vals_blue = PCA_transformer(b, 200) # Gathering all the reconstructed image data for blue component
    final_image = np.dstack((red_recon, green_recon, blue_recon))
    final_image = Image.fromarray(final_image)

    plt.suptitle("Output Image for 200 Principal Components")
    plt.imshow(final_image) # Final image after image compression using PCA

    # Plot for showing the Accumulative Variance v/s Number of PCs for red channel
    fig = plt.figure(figsize=(13, 10))
    fig.add_subplot(131)
    plt.title("Red Channel")
    plt.ylabel("Accumulative Variance")
    plt.xlabel("Number of PCs")
    plt.bar(list(range(1,201)), vals_red, color = "red")

    # Plot for showing the Accumulative Variance v/s Number of PCs for green channel
    fig.add_subplot(132)
    plt.title("Green Channel")
    plt.ylabel("Accumulative Variance")
    plt.xlabel("Number of PCs")
    plt.bar(list(range(1,201)), vals_green, color = "green")

    # Plot for showing the Accumulative Variance v/s Number of PCs for blue channel
    fig.add_subplot(133)
    plt.title("Blue Channel")
    plt.ylabel("Accumulative Variance")
    plt.xlabel("Number of PCs")
    plt.bar(list(range(1,201)), vals_blue, color = "blue")

    plt.suptitle("Output for 200 Principal Components")
    plt.show()

    """Output for 300 Principal Components"""

    red_recon, vals_red = PCA_transformer(r, 300)  # Gathering all the reconstructed image data for red component
    green_recon, vals_green = PCA_transformer(g, 300)  # Gathering all the reconstructed image data for green component
    blue_recon, vals_blue = PCA_transformer(b, 300) # Gathering all the reconstructed image data for blue component
    final_image = np.dstack((red_recon, green_recon, blue_recon))
    final_image = Image.fromarray(final_image)

    plt.suptitle("Output Image for 300 Principal Components")
    plt.imshow(final_image) # Final image after image compression using PCA

    # Plot for showing the Accumulative Variance v/s Number of PCs for red channel
    fig = plt.figure(figsize=(13, 10))
    fig.add_subplot(131)
    plt.title("Red Channel")
    plt.ylabel("Accumulative Variance")
    plt.xlabel("Number of PCs")
    plt.bar(list(range(1,301)), vals_red, color = "red")

    # Plot for showing the Accumulative Variance v/s Number of PCs for green channel
    fig.add_subplot(132)
    plt.title("Green Channel")
    plt.ylabel("Accumulative Variance")
    plt.xlabel("Number of PCs")
    plt.bar(list(range(1,301)), vals_green, color = "green")

    # Plot for showing the Accumulative Variance v/s Number of PCs for blue channel
    fig.add_subplot(133)
    plt.title("Blue Channel")
    plt.ylabel("Accumulative Variance")
    plt.xlabel("Number of PCs")
    plt.bar(list(range(1,301)), vals_blue, color = "blue")

    plt.suptitle("Output for 300 Principal Components")
    plt.show()

    """Output for 400 Principal Components"""

    red_recon, vals_red = PCA_transformer(r, 400)  # Gathering all the reconstructed image data for red component
    green_recon, vals_green = PCA_transformer(g, 400)  # Gathering all the reconstructed image data for green component
    blue_recon, vals_blue = PCA_transformer(b, 400) # Gathering all the reconstructed image data for blue component
    final_image = np.dstack((red_recon, green_recon, blue_recon))
    final_image = Image.fromarray(final_image)

    plt.suptitle("Output Image for 400 Principal Components")
    plt.imshow(final_image) # Final image after image compression using PCA

    # Plot for showing the Accumulative Variance v/s Number of PCs for red channel
    fig = plt.figure(figsize=(13, 10))
    fig.add_subplot(131)
    plt.title("Red Channel")
    plt.ylabel("Accumulative Variance")
    plt.xlabel("Number of PCs")
    plt.bar(list(range(1,401)), vals_red, color = "red")

    # Plot for showing the Accumulative Variance v/s Number of PCs for green channel
    fig.add_subplot(132)
    plt.title("Green Channel")
    plt.ylabel("Accumulative Variance")
    plt.xlabel("Number of PCs")
    plt.bar(list(range(1,401)), vals_green, color = "green")

    # Plot for showing the Accumulative Variance v/s Number of PCs for blue channel
    fig.add_subplot(133)
    plt.title("Blue Channel")
    plt.ylabel("Accumulative Variance")
    plt.xlabel("Number of PCs")
    plt.bar(list(range(1,401)), vals_blue, color = "blue")

    plt.suptitle("Output for 400 Principal Components")
    plt.show()